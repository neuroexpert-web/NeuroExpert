import { NextResponse } from 'next/server';
import { apiRateLimit } from '@/app/middleware/rateLimit';
import { validate, schemas } from '@/app/utils/validation';

async function handler(request) {
  try {
    const data = await request.json();
    
    // –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Å—Ö–µ–º—ã
    const validationResult = validate(data, schemas.contactForm);
    
    if (!validationResult.isValid) {
      // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–µ—Ä–≤—É—é –æ—à–∏–±–∫—É –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      const firstError = Object.values(validationResult.errors)[0];
      return NextResponse.json(
        { error: firstError },
        { status: 400 }
      );
    }
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∞–Ω–∏—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    const { name, email, phone, message } = validationResult.sanitizedData;
    
    // Log the submission (in production, save to database)
    console.log('Contact form submission:', {
      name,
      email,
      phone,
      message,
      timestamp: new Date().toISOString()
    });
    
    // Log submission for debugging
    console.log('New contact form submission:', {
      name,
      email,
      phone,
      message,
      timestamp: new Date().toISOString(),
      hasToken: !!process.env.TELEGRAM_BOT_TOKEN,
      hasChatId: !!process.env.TELEGRAM_CHAT_ID
    });
    
    // Send notification to Telegram if configured
    if (process.env.TELEGRAM_BOT_TOKEN && process.env.TELEGRAM_CHAT_ID) {
      try {
        // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        console.log('Attempting to send Telegram notification:', {
          hasToken: !!process.env.TELEGRAM_BOT_TOKEN,
          tokenLength: process.env.TELEGRAM_BOT_TOKEN?.length,
          chatId: process.env.TELEGRAM_CHAT_ID,
          chatIdType: typeof process.env.TELEGRAM_CHAT_ID
        });
        
        const telegramMessage = `
üîî –ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ —Å —Å–∞–π—Ç–∞ NeuroExpert

üë§ –ò–º—è: ${name}
üìß Email: ${email}
üì± –¢–µ–ª–µ—Ñ–æ–Ω: ${phone || '–ù–µ —É–∫–∞–∑–∞–Ω'}
üí¨ –°–æ–æ–±—â–µ–Ω–∏–µ: ${message}
üïê –í—Ä–µ–º—è: ${new Date().toLocaleString('ru-RU')}
        `;
        
        const telegramUrl = `https://api.telegram.org/bot${process.env.TELEGRAM_BOT_TOKEN}/sendMessage`;
        console.log('Telegram URL:', telegramUrl.replace(process.env.TELEGRAM_BOT_TOKEN, 'TOKEN_HIDDEN'));
        
        const response = await fetch(
          telegramUrl,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              chat_id: process.env.TELEGRAM_CHAT_ID,
              text: telegramMessage
            })
          }
        );
        
        const responseData = await response.json();
        
        if (!response.ok || !responseData.ok) {
          console.error('Failed to send Telegram notification:', {
            status: response.status,
            statusText: response.statusText,
            error: responseData
          });
        } else {
          console.log('Telegram notification sent successfully:', {
            messageId: responseData.result?.message_id,
            chatId: responseData.result?.chat?.id
          });
        }
      } catch (error) {
        console.error('Telegram notification error:', error);
        // Don't fail the request if Telegram fails
      }
    } else {
      console.warn('Telegram notifications not configured. Set TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID environment variables.');
    }
    
    // Return success response
    return NextResponse.json({
      success: true,
      message: '–°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à—É –∑–∞—è–≤–∫—É! –ú—ã —Å–≤—è–∂–µ–º—Å—è —Å –≤–∞–º–∏ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.'
    });
    
  } catch (error) {
    console.error('Contact form error:', error);
    return NextResponse.json(
      { error: '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–æ—Ä–º—ã' },
      { status: 500 }
    );
  }
}

// Export the POST handler
export async function POST(request) {
  // Temporarily disabled rate limiting for deployment
  // TODO: Fix rate limiter return type
  return handler(request);
}